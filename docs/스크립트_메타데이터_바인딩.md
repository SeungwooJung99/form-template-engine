# FTL + JavaScript + React.js ì™¸ë¶€ ì„œë²„ ë°ì´í„° ë°”ì¸ë”© ì™„ì „ ê°€ì´ë“œ

## ğŸ¯ ê°œìš”

FreeMarker í…œí”Œë¦¿(.ftl)ì—ì„œ **JavaScriptë¥¼ í¬í•¨í•˜ì—¬ HTMLì„ ìƒì„±**í•˜ê³ , **React.js ì™¸ë¶€ ì„œë²„ì—ì„œ ë™ì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë°”ì¸ë”©**í•˜ëŠ” ì™„ì „í•œ ì†”ë£¨ì…˜ì…ë‹ˆë‹¤.

### ğŸ”„ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```
[FTL ì„œë²„] â†’ [HTML + JS + Metadata] â†’ [React.js ì„œë²„] â†’ [API ì¡°íšŒ] â†’ [ë°ì´í„° ë°”ì¸ë”©] â†’ [ë Œë”ë§]
```

---

## ğŸ“ 1. FTLì—ì„œ JavaScript ì‚¬ìš©

### ê¸°ë³¸ JavaScript í¬í•¨ ì˜ˆì‹œ

```ftl
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>${document.title!"ë™ì  ëŒ€ì‹œë³´ë“œ"}</title>
    
    <!-- FTLì—ì„œ ë©”íƒ€ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ì„ë² ë”© -->
    <script id="template-metadata" type="application/json">
    {
        "templateId": "${template.id!'dashboard'}",
        "version": "${template.version!'1.0.0'}",
        "dataBindings": {
            "user": {
                "endpoint": "/api/users/${user.id!'current'}",
                "fields": ["name", "email", "avatar", "role"],
                "fallback": {
                    "name": "${user.name!'ì‚¬ìš©ì'}",
                    "email": "${user.email!''}",
                    "avatar": "${user.avatar!'/images/default-avatar.png'}",
                    "role": "${user.role!'user'}"
                }
            },
            "dashboard": {
                "endpoint": "/api/dashboard/stats",
                "fields": ["sales", "orders", "users"],
                "fallback": {
                    "sales": ${dashboard.sales!0},
                    "orders": ${dashboard.orders!0},
                    "users": ${dashboard.users!0}
                }
            }
        },
        "config": {
            "apiBaseUrl": "${api.baseUrl!'http://localhost:3001'}",
            "refreshInterval": ${config.refreshInterval!30000},
            "debug": ${config.debug!false}
        }
    }
    </script>
</head>
<body>
    <!-- ë¡œë”© ìƒíƒœ -->
    <div id="loading-overlay">
        <div class="spinner">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
    </div>

    <!-- ë©”ì¸ ì»¨í…ì¸  -->
    <div id="main-content" style="display: none;">
        <header>
            <h1>ëŒ€ì‹œë³´ë“œ</h1>
            <div class="user-info">
                <img data-bind="user.avatar" src="${user.avatar!'/images/default-avatar.png'}" alt="í”„ë¡œí•„" />
                <span data-bind="user.name">${user.name!'ì‚¬ìš©ì'}</span>
                <span data-bind="user.email" class="email">${user.email!''}</span>
            </div>
        </header>

        <main class="dashboard">
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>ì´ ë§¤ì¶œ</h3>
                    <span data-bind="dashboard.sales" data-format="currency">
                        ${dashboard.sales!0}
                    </span>
                </div>
                <div class="stat-card">
                    <h3>ì£¼ë¬¸ ìˆ˜</h3>
                    <span data-bind="dashboard.orders" data-format="number">
                        ${dashboard.orders!0}
                    </span>
                </div>
                <div class="stat-card">
                    <h3>ì‚¬ìš©ì ìˆ˜</h3>
                    <span data-bind="dashboard.users" data-format="number">
                        ${dashboard.users!0}
                    </span>
                </div>
            </div>
        </main>
    </div>

    <!-- ë°ì´í„° ë°”ì¸ë”© JavaScript -->
    <script>
    class TemplateDataBinder {
        constructor() {
            this.metadata = null;
            this.boundData = {};
            this.isReady = false;
            this.refreshTimer = null;
            this.init();
        }

        async init() {
            try {
                // ë©”íƒ€ë°ì´í„° ë¡œë”©
                const metadataScript = document.getElementById('template-metadata');
                this.metadata = JSON.parse(metadataScript.textContent);
                
                console.log('ğŸš€ Template initialized:', this.metadata.templateId);
                
                // React ì„œë²„ì—ì„œ ë°ì´í„° ë°”ì¸ë”©
                await this.bindDataFromReactServer();
                
                // onReady ì´ë²¤íŠ¸ í˜¸ì¶œ
                this.onReady();
                
            } catch (error) {
                console.error('âŒ Initialization failed:', error);
                this.onError(error);
            }
        }

        async bindDataFromReactServer() {
            const { dataBindings, config } = this.metadata;
            
            console.log('ğŸ”„ Starting data binding from React server...');
            
            for (const [key, binding] of Object.entries(dataBindings)) {
                try {
                    console.log(`ğŸ“¥ Fetching ${key} from ${binding.endpoint}`);
                    
                    const data = await this.fetchFromReactAPI(binding.endpoint, config);
                    
                    if (data) {
                        this.boundData[key] = data;
                        this.updateUIElements(key, data);
                        console.log(`âœ… ${key} data bound successfully`);
                    } else {
                        console.log(`âš ï¸ Using fallback data for ${key}`);
                        this.boundData[key] = binding.fallback;
                        this.updateUIElements(key, binding.fallback);
                    }
                    
                } catch (error) {
                    console.error(`âŒ Failed to bind ${key}:`, error);
                    this.boundData[key] = binding.fallback;
                    this.updateUIElements(key, binding.fallback);
                }
            }
            
            console.log('ğŸ‰ Data binding completed');
            this.onDataBound();
        }

        async fetchFromReactAPI(endpoint, config) {
            const url = `${config.apiBaseUrl}${endpoint}`;
            
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Template-ID': this.metadata.templateId,
                        'X-Requested-With': 'TemplateDataBinder'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return await response.json();
                
            } catch (error) {
                console.error(`Network error for ${endpoint}:`, error);
                return null;
            }
        }

        updateUIElements(dataKey, data) {
            const elements = document.querySelectorAll(`[data-bind^="${dataKey}."]`);
            
            elements.forEach(element => {
                const bindPath = element.getAttribute('data-bind');
                const fieldPath = bindPath.replace(`${dataKey}.`, '');
                const value = this.getNestedValue(data, fieldPath);
                
                if (value !== undefined) {
                    this.setElementValue(element, value);
                    element.classList.remove('data-placeholder');
                } else {
                    console.warn(`âš ï¸ No value found for ${bindPath}`);
                }
            });
        }

        getNestedValue(obj, path) {
            return path.split('.').reduce((current, key) => 
                current && current[key] !== undefined ? current[key] : undefined, obj);
        }

        setElementValue(element, value) {
            const format = element.getAttribute('data-format');
            let displayValue = value;

            if (format === 'currency') {
                displayValue = new Intl.NumberFormat('ko-KR', {
                    style: 'currency',
                    currency: 'KRW'
                }).format(value);
            } else if (format === 'number') {
                displayValue = new Intl.NumberFormat('ko-KR').format(value);
            }

            if (element.tagName === 'INPUT') {
                element.value = displayValue;
            } else if (element.tagName === 'IMG') {
                element.src = value;
            } else {
                element.textContent = displayValue;
            }
        }

        // ğŸ¯ ìƒëª…ì£¼ê¸° ì´ë²¤íŠ¸ë“¤
        onReady() {
            console.log('ğŸ¯ onReady: Template is ready and data is bound');
            
            document.getElementById('loading-overlay').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';
            
            this.isReady = true;
            
            // ìë™ ìƒˆë¡œê³ ì¹¨ ì„¤ì •
            this.setupAutoRefresh();
            
            // ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ë°œìƒ
            document.dispatchEvent(new CustomEvent('templateReady', {
                detail: { templateId: this.metadata.templateId, boundData: this.boundData }
            }));
        }

        onDataBound() {
            console.log('ğŸ“Š onDataBound: All data binding completed');
            
            document.dispatchEvent(new CustomEvent('dataBound', {
                detail: { boundData: this.boundData, timestamp: new Date().toISOString() }
            }));
        }

        onDestroy() {
            console.log('ğŸ’€ onDestroy: Cleaning up template');
            
            if (this.refreshTimer) {
                clearInterval(this.refreshTimer);
            }
            
            document.dispatchEvent(new CustomEvent('templateDestroy', {
                detail: { templateId: this.metadata.templateId }
            }));
        }

        onError(error) {
            console.error('ğŸ’¥ onError:', error);
            document.getElementById('loading-overlay').innerHTML = `
                <div style="text-align: center; color: red;">
                    <h3>ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</h3>
                    <p>${error.message}</p>
                    <button onclick="location.reload()">ë‹¤ì‹œ ì‹œë„</button>
                </div>
            `;
        }

        setupAutoRefresh() {
            const interval = this.metadata.config.refreshInterval;
            if (interval > 0) {
                this.refreshTimer = setInterval(() => {
                    console.log('ğŸ”„ Auto refreshing data...');
                    this.bindDataFromReactServer();
                }, interval);
            }
        }

        // ê³µê°œ API
        refresh() {
            return this.bindDataFromReactServer();
        }

        getData(key) {
            return this.boundData[key];
        }
    }

    // ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
    let templateBinder;

    document.addEventListener('DOMContentLoaded', () => {
        templateBinder = new TemplateDataBinder();
    });

    window.addEventListener('beforeunload', () => {
        if (templateBinder) {
            templateBinder.onDestroy();
        }
    });

    // ì „ì—­ API
    window.TemplateAPI = {
        refresh: () => templateBinder?.refresh(),
        getData: (key) => templateBinder?.getData(key),
        isReady: () => templateBinder?.isReady || false
    };
    </script>

    <!-- FTLì—ì„œ ì¶”ê°€ ìŠ¤í¬ë¦½íŠ¸ (ì¡°ê±´ë¶€) -->
    <#if customScripts?? && customScripts?has_content>
        <#list customScripts as script>
            <script src="${script}"></script>
        </#list>
    </#if>
</body>
</html>
```

---

## âš›ï¸ 2. React.js ì™¸ë¶€ ì„œë²„ êµ¬í˜„

### í”„ë¡œì íŠ¸ êµ¬ì¡°

```
react-template-server/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ TemplateRenderer.jsx
â”‚   â”‚   â””â”€â”€ TemplateProcessor.jsx
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ apiService.js
â”‚   â”‚   â””â”€â”€ templateService.js
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ useTemplateData.js
â”‚   â””â”€â”€ App.jsx
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ users.js
â”‚   â”‚   â”œâ”€â”€ dashboard.js
â”‚   â”‚   â””â”€â”€ templates.js
â”‚   â””â”€â”€ server.js
â””â”€â”€ package.json
```

### React ì»´í¬ë„ŒíŠ¸: TemplateRenderer.jsx

```jsx
import React, {useState, useEffect, useRef} from 'react';
import {apiService} from '../services/apiService';
import {templateService} from '../services/templateService';

const TemplateRenderer = ({htmlContent, onReady, onError}) => {
    const [isProcessing, setIsProcessing] = useState(true);
    const [processedHtml, setProcessedHtml] = useState('');
    const [templateData, setTemplateData] = useState({});
    const containerRef = useRef(null);

    useEffect(() => {
        if (htmlContent) {
            processTemplate(htmlContent);
        }
    }, [htmlContent]);

    const processTemplate = async (html) => {
        try {
            console.log('ğŸš€ React: Starting template processing...');

            // 1. HTMLì—ì„œ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
            const metadata = templateService.extractMetadata(html);
            console.log('ğŸ“‹ Extracted metadata:', metadata);

            // 2. ê° ë°ì´í„° ë°”ì¸ë”©ì— ëŒ€í•´ API í˜¸ì¶œ
            const boundData = {};

            for (const [key, binding] of Object.entries(metadata.dataBindings)) {
                try {
                    console.log(`ğŸ“¥ React: Fetching ${key} from ${binding.endpoint}`);

                    const data = await apiService.fetchData(binding.endpoint);
                    boundData[key] = data || binding.fallback;

                    console.log(`âœ… React: ${key} data fetched:`, data);
                } catch (error) {
                    console.error(`âŒ React: Failed to fetch ${key}:`, error);
                    boundData[key] = binding.fallback;
                }
            }

            // 3. HTMLì— ë°ì´í„° ë°”ì¸ë”© ì ìš©
            const processedHtml = templateService.bindDataToHTML(html, boundData, metadata);

            setTemplateData(boundData);
            setProcessedHtml(processedHtml);
            setIsProcessing(false);

            console.log('ğŸ‰ React: Template processing completed');

            // 4. DOMì— ì‚½ì… í›„ JavaScript ì‹¤í–‰
            setTimeout(() => {
                executeTemplateScripts(boundData, metadata);
            }, 100);

        } catch (error) {
            console.error('ğŸ’¥ React: Template processing failed:', error);
            setIsProcessing(false);
            onError?.(error);
        }
    };

    const executeTemplateScripts = (boundData, metadata) => {
        try {
            console.log('âš¡ React: Executing template scripts...');

            // HTMLì— í¬í•¨ëœ JavaScript ì‹¤í–‰ì„ ìœ„í•œ ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ë°œìƒ
            const event = new CustomEvent('reactTemplateReady', {
                detail: {
                    boundData,
                    metadata,
                    reactContext: {
                        updateData: (key, newData) => updateTemplateData(key, newData),
                        refreshData: () => processTemplate(htmlContent),
                        getReactState: () => templateData
                    }
                }
            });

            window.dispatchEvent(event);
            onReady?.(boundData, metadata);

        } catch (error) {
            console.error('âŒ React: Script execution failed:', error);
            onError?.(error);
        }
    };

    const updateTemplateData = (key, newData) => {
        setTemplateData(prev => ({
            ...prev,
            [key]: newData
        }));

        // DOM ìš”ì†Œë“¤ë„ ì—…ë°ì´íŠ¸
        templateService.updateDOMElements(key, newData);
    };

    if (isProcessing) {
        return (
            <div className="template-processing">
                <div className="spinner">
                    <div className="spinner-border" role="status">
                        <span className="sr-only">í…œí”Œë¦¿ ì²˜ë¦¬ ì¤‘...</span>
                    </div>
                </div>
                <p>Reactì—ì„œ í…œí”Œë¦¿ì„ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>
            </div>
        );
    }

    return (
        <div
            ref={containerRef}
            className="template-container"
            dangerouslySetInnerHTML={{__html: processedHtml}}
        />
    );
};

export default TemplateRenderer;
```

### React Hook: useTemplateData.js

```jsx
import {useState, useEffect, useCallback} from 'react';
import {apiService} from '../services/apiService';

export const useTemplateData = (metadata) => {
    const [data, setData] = useState({});
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchData = useCallback(async () => {
        if (!metadata?.dataBindings) return;

        setLoading(true);
        setError(null);

        try {
            const results = {};

            // ë³‘ë ¬ë¡œ ëª¨ë“  API í˜¸ì¶œ
            const promises = Object.entries(metadata.dataBindings).map(async ([key, binding]) => {
                try {
                    const result = await apiService.fetchData(binding.endpoint);
                    results[key] = result || binding.fallback;
                } catch (err) {
                    console.error(`Failed to fetch ${key}:`, err);
                    results[key] = binding.fallback;
                }
            });

            await Promise.all(promises);

            setData(results);
            console.log('ğŸ¯ useTemplateData: All data fetched:', results);

        } catch (err) {
            setError(err);
            console.error('ğŸ’¥ useTemplateData: Fetch failed:', err);
        } finally {
            setLoading(false);
        }
    }, [metadata]);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    const updateData = useCallback((key, newData) => {
        setData(prev => ({
            ...prev,
            [key]: newData
        }));
    }, []);

    const refreshData = useCallback(() => {
        return fetchData();
    }, [fetchData]);

    return {
        data,
        loading,
        error,
        updateData,
        refreshData,
        refetch: fetchData
    };
};
```

### í…œí”Œë¦¿ ì„œë¹„ìŠ¤: templateService.js

```javascript
class TemplateService {
    extractMetadata(html) {
        try {
            const metadataMatch = html.match(/<script id="template-metadata"[^>]*>([\s\S]*?)<\/script>/);
            if (!metadataMatch) {
                throw new Error('Template metadata not found');
            }

            return JSON.parse(metadataMatch[1]);
        } catch (error) {
            console.error('Failed to extract metadata:', error);
            throw error;
        }
    }

    bindDataToHTML(html, boundData, metadata) {
        let processedHtml = html;

        // ë©”íƒ€ë°ì´í„°ë¥¼ ì‹¤ì œ ë°ì´í„°ë¡œ ì—…ë°ì´íŠ¸
        const updatedMetadata = {
            ...metadata,
            boundData,
            processedAt: new Date().toISOString()
        };

        // ë©”íƒ€ë°ì´í„° ìŠ¤í¬ë¦½íŠ¸ íƒœê·¸ ì—…ë°ì´íŠ¸
        processedHtml = processedHtml.replace(
            /<script id="template-metadata"[^>]*>[\s\S]*?<\/script>/,
            `<script id="template-metadata" type="application/json">
            ${JSON.stringify(updatedMetadata, null, 2)}
            </script>`
        );

        // data-bind ì†ì„±ì„ ê°€ì§„ ìš”ì†Œë“¤ì˜ ê¸°ë³¸ê°’ ì—…ë°ì´íŠ¸
        Object.entries(boundData).forEach(([key, data]) => {
            Object.entries(data).forEach(([field, value]) => {
                const bindAttr = `${key}.${field}`;
                const regex = new RegExp(`data-bind="${bindAttr}"[^>]*>([^<]*)<`, 'g');

                processedHtml = processedHtml.replace(regex, (match, currentContent) => {
                    const formattedValue = this.formatValue(value, match);
                    return match.replace(currentContent, formattedValue);
                });
            });
        });

        return processedHtml;
    }

    formatValue(value, elementMatch) {
        if (elementMatch.includes('data-format="currency"')) {
            return new Intl.NumberFormat('ko-KR', {
                style: 'currency',
                currency: 'KRW'
            }).format(value);
        } else if (elementMatch.includes('data-format="number"')) {
            return new Intl.NumberFormat('ko-KR').format(value);
        }

        return value;
    }

    updateDOMElements(key, data) {
        const elements = document.querySelectorAll(`[data-bind^="${key}."]`);

        elements.forEach(element => {
            const bindPath = element.getAttribute('data-bind');
            const fieldPath = bindPath.replace(`${key}.`, '');
            const value = this.getNestedValue(data, fieldPath);

            if (value !== undefined) {
                if (element.tagName === 'IMG') {
                    element.src = value;
                } else if (element.tagName === 'INPUT') {
                    element.value = value;
                } else {
                    const formattedValue = this.formatValue(value, element.outerHTML);
                    element.textContent = formattedValue;
                }
            }
        });
    }

    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) =>
            current && current[key] !== undefined ? current[key] : undefined, obj);
    }
}

export const templateService = new TemplateService();
```

### API ì„œë¹„ìŠ¤: apiService.js

```javascript
class ApiService {
    constructor() {
        this.baseURL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001';
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5ë¶„
    }

    async fetchData(endpoint) {
        const cacheKey = endpoint;
        const cached = this.cache.get(cacheKey);

        // ìºì‹œ í™•ì¸
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            console.log(`ğŸ“¦ Using cached data for ${endpoint}`);
            return cached.data;
        }

        try {
            const url = `${this.baseURL}${endpoint}`;
            console.log(`ğŸŒ Fetching from: ${url}`);

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'React-Template-Server'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            // ìºì‹œì— ì €ì¥
            this.cache.set(cacheKey, {
                data,
                timestamp: Date.now()
            });

            return data;

        } catch (error) {
            console.error(`API call failed for ${endpoint}:`, error);
            throw error;
        }
    }

    clearCache(endpoint) {
        if (endpoint) {
            this.cache.delete(endpoint);
        } else {
            this.cache.clear();
        }
    }
}

export const apiService = new ApiService();
```

---

## ğŸŒ 3. Express.js API ì„œë²„ (React ë°±ì—”ë“œ)

### server.js

```javascript
const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3001;

// ë¯¸ë“¤ì›¨ì–´
app.use(cors());
app.use(express.json({limit: '10mb'}));
app.use(express.static('public'));

// ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
    next();
});

// ì‚¬ìš©ì API
app.get('/api/users/:id', async (req, res) => {
    try {
        const userId = req.params.id;

        // ì‹¤ì œë¡œëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
        const userData = {
            current: {
                name: 'ê¹€ê°œë°œì',
                email: 'developer@example.com',
                avatar: '/images/avatar-developer.jpg',
                role: 'admin'
            },
            'user-123': {
                name: 'ë°•ì‚¬ìš©ì',
                email: 'user@example.com',
                avatar: '/images/avatar-user.jpg',
                role: 'user'
            }
        };

        const user = userData[userId] || userData.current;

        console.log(`ğŸ‘¤ User data requested for: ${userId}`);
        res.json(user);

    } catch (error) {
        console.error('User API error:', error);
        res.status(500).json({error: 'Failed to fetch user data'});
    }
});

// ëŒ€ì‹œë³´ë“œ í†µê³„ API
app.get('/api/dashboard/stats', async (req, res) => {
    try {
        // ì‹¤ì œë¡œëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ê³„ì‚°
        const stats = {
            sales: Math.floor(Math.random() * 10000000) + 5000000,
            orders: Math.floor(Math.random() * 1000) + 500,
            users: Math.floor(Math.random() * 10000) + 5000
        };

        console.log('ğŸ“Š Dashboard stats requested');
        res.json(stats);

    } catch (error) {
        console.error('Dashboard API error:', error);
        res.status(500).json({error: 'Failed to fetch dashboard stats'});
    }
});

// ì•Œë¦¼ API
app.get('/api/notifications/count', async (req, res) => {
    try {
        const notifications = {
            unread: Math.floor(Math.random() * 20),
            total: Math.floor(Math.random() * 100) + 50
        };

        console.log('ğŸ”” Notifications requested');
        res.json(notifications);

    } catch (error) {
        console.error('Notifications API error:', error);
        res.status(500).json({error: 'Failed to fetch notifications'});
    }
});

// í…œí”Œë¦¿ ì²˜ë¦¬ API (React ì„œë²„ë¡œë¶€í„° HTML ìˆ˜ì‹ )
app.post('/api/templates/process', async (req, res) => {
    try {
        const {html, templateId} = req.body;

        console.log(`ğŸ“ Processing template: ${templateId}`);

        // ì—¬ê¸°ì„œ ì¶”ê°€ì ì¸ ì„œë²„ì‚¬ì´ë“œ ì²˜ë¦¬ ê°€ëŠ¥
        // ì˜ˆ: ê¶Œí•œ í™•ì¸, ë¡œê¹…, ë¶„ì„ ë“±

        res.json({
            success: true,
            templateId,
            processedAt: new Date().toISOString(),
            message: 'Template processed successfully'
        });

    } catch (error) {
        console.error('Template processing error:', error);
        res.status(500).json({error: 'Failed to process template'});
    }
});

// í—¬ìŠ¤ì²´í¬
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
    });
});

app.listen(PORT, () => {
    console.log(`ğŸš€ React Template Server running on port ${PORT}`);
    console.log(`ğŸ“Š Dashboard API: http://localhost:${PORT}/api/dashboard/stats`);
    console.log(`ğŸ‘¤ User API: http://localhost:${PORT}/api/users/current`);
    console.log(`ğŸ’Š Health Check: http://localhost:${PORT}/health`);
});
```

---

## ğŸ­ 4. ìƒëª…ì£¼ê¸° ì´ë²¤íŠ¸ ìƒì„¸

### onReady ì´ë²¤íŠ¸ ì²˜ë¦¬

```javascript
// FTLì—ì„œ ìƒì„±ëœ HTMLì˜ JavaScript
window.addEventListener('reactTemplateReady', (event) => {
    const {boundData, metadata, reactContext} = event.detail;

    console.log('ğŸ¯ Reactì™€ Template ì—°ë™ ì™„ë£Œ!');

    // React ì»¨í…ìŠ¤íŠ¸ë¥¼ í†µí•œ ì–‘ë°©í–¥ í†µì‹ 
    window.ReactAPI = {
        updateData: reactContext.updateData,
        refreshData: reactContext.refreshData,
        getReactState: reactContext.getReactState
    };

    // í…œí”Œë¦¿ ìì²´ onReady ì‹¤í–‰
    if (window.templateBinder) {
        window.templateBinder.onReady();
    }

    // ì¶”ê°€ ì´ˆê¸°í™” ë¡œì§
    initializeCharts(boundData);
    setupRealTimeUpdates();
});

function initializeCharts(data) {
    // ì°¨íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™”
    if (window.Chart && data.dashboard) {
        const ctx = document.getElementById('salesChart');
        if (ctx) {
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['1ì›”', '2ì›”', '3ì›”', '4ì›”', '5ì›”', '6ì›”'],
                    datasets: [{
                        label: 'ë§¤ì¶œ',
                        data: generateChartData(data.dashboard.sales),
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1
                    }]
                }
            });
        }
    }
}

function setupRealTimeUpdates() {
    // WebSocket ì—°ê²° (ì„ íƒì )
    if (window.io) {
        const socket = io();

        socket.on('dashboard-update', (data) => {
            console.log('ğŸ“Š Real-time dashboard update received');
            window.ReactAPI.updateData('dashboard', data);
        });

        socket.on('user-update', (data) => {
            console.log('ğŸ‘¤ Real-time user update received');
            window.ReactAPI.updateData('user', data);
        });
    }
}
```

### onDestroy ì´ë²¤íŠ¸ ì²˜ë¦¬

```javascript
window.addEventListener('beforeunload', () => {
    console.log('ğŸ’€ Page unloading - cleaning up...');

    // WebSocket ì—°ê²° ì •ë¦¬
    if (window.socket) {
        window.socket.disconnect();
    }

    // íƒ€ì´ë¨¸ ì •ë¦¬
    if (window.refreshTimer) {
        clearInterval(window.refreshTimer);
    }

    // Reactì—ê²Œ ì •ë¦¬ ì•Œë¦¼
    if (window.ReactAPI) {
        const event = new CustomEvent('templateDestroy', {
            detail: {timestamp: new Date().toISOString()}
        });
        window.dispatchEvent(event);
    }
});
```

---

## ğŸ”„ 5. ì™„ì „í•œ í†µí•© ì˜ˆì‹œ

### App.jsx (React ë©”ì¸ ì»´í¬ë„ŒíŠ¸)

```jsx
import React, {useState, useEffect} from 'react';
import TemplateRenderer from './components/TemplateRenderer';
import './App.css';

function App() {
    const [htmlContent, setHtmlContent] = useState('');
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        // FTL ì„œë²„ì—ì„œ HTML ìˆ˜ì‹  ì‹œë®¬ë ˆì´ì…˜
        // ì‹¤ì œë¡œëŠ” POST ìš”ì²­ìœ¼ë¡œ ë°›ì•„ì˜¬ ê²ƒ
        fetchTemplateFromFTLServer();
    }, []);

    const fetchTemplateFromFTLServer = async () => {
        try {
            // ì‹¤ì œ FTL ì„œë²„ì—ì„œ HTMLì„ ë°›ì•„ì˜¤ëŠ” ë¡œì§
            // ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            const mockHtmlFromFTL = await simulateFTLResponse();

            setHtmlContent(mockHtmlFromFTL);
            setIsLoading(false);

        } catch (err) {
            setError(err);
            setIsLoading(false);
        }
    };

    const simulateFTLResponse = () => {
        // ì‹¤ì œë¡œëŠ” FTL ì„œë²„ì—ì„œ ìƒì„±ëœ HTMLì´ ì—¬ê¸°ì— ë“¤ì–´ê°
        return Promise.resolve(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>ë™ì  ëŒ€ì‹œë³´ë“œ</title>
                <script id="template-metadata" type="application/json">
                {
                    "templateId": "dashboard-001",
                    "dataBindings": {
                        "user": {
                            "endpoint": "/api/users/current",
                            "fallback": {"name": "ì‚¬ìš©ì", "email": ""}
                        },
                        "dashboard": {
                            "endpoint": "/api/dashboard/stats", 
                            "fallback": {"sales": 0, "orders": 0}
                        }
                    }
                }
                </script>
            </head>
            <body>
                <h1>ëŒ€ì‹œë³´ë“œ</h1>
                <p>ì•ˆë…•í•˜ì„¸ìš”, <span data-bind="user.name">ì‚¬ìš©ì</span>ë‹˜!</p>
                <p>ì´ ë§¤ì¶œ: <span data-bind="dashboard.sales" data-format="currency">0</span></p>
            </body>
            </html>
        `);
    };

    const handleTemplateReady = (boundData, metadata) => {
        console.log('ğŸ‰ Template ready in React:', {boundData, metadata});

        // ë¶„ì„ ì´ë²¤íŠ¸ ì „ì†¡
        if (window.gtag) {
            window.gtag('event', 'template_rendered', {
                template_id: metadata.templateId,
                data_sources: Object.keys(boundData).length
            });
        }
    };

    const handleTemplateError = (error) => {
        console.error('ğŸ’¥ Template error in React:', error);
        setError(error);
    };

    if (isLoading) {
        return (
            <div className="app-loading">
                <div className="spinner-border" role="status">
                    <span className="sr-only">FTL í…œí”Œë¦¿ ë¡œë”© ì¤‘...</span>
                </div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="app-error">
                <h2>ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</h2>
                <p>{error.message}</p>
                <button onClick={() => window.location.reload()}>
                    ë‹¤ì‹œ ì‹œë„
                </button>
            </div>
        );
    }

    return (
        <div className="App">
            <header className="app-header">
                <h1>React Template Renderer</h1>
                <p>FTL â†’ HTML â†’ React â†’ Data Binding â†’ Final Render</p>
            </header>

            <main className="app-main">
                <TemplateRenderer
                    htmlContent={htmlContent}
                    onReady={handleTemplateReady}
                    onError={handleTemplateError}
                />
            </main>

            <footer className="app-footer">
                <p>Powered by FreeMarker + React.js</p>
            </footer>
        </div>
    );
}

export default App;
```

---

## ğŸš€ 6. ì‹¤í–‰ ë° í…ŒìŠ¤íŠ¸

### ì„¤ì¹˜ ë° ì‹¤í–‰

```bash
# React í”„ë¡œì íŠ¸ ìƒì„±
npx create-react-app react-template-server
cd react-template-server

# í•„ìš”í•œ íŒ¨í‚¤ì§€ ì„¤ì¹˜
npm install express cors
npm install -D nodemon

# ê°œë°œ ì„œë²„ ì‹¤í–‰
npm run dev     # React ê°œë°œ ì„œë²„ (3000)
npm run server  # Express API ì„œë²„ (3001)
```

### package.json ìŠ¤í¬ë¦½íŠ¸

```json
{
  "scripts": {
    "start": "react-scripts start",
    "server": "nodemon server/server.js",
    "dev": "concurrently \"npm run server\" \"npm start\"",
    "build": "react-scripts build",
    "test": "react-scripts test"
  }
}
```

---

## ğŸ“Š 7. ì„±ëŠ¥ ë° ëª¨ë‹ˆí„°ë§

### ì„±ëŠ¥ ìµœì í™”

```javascript
// ë°ì´í„° ìºì‹±
const DataCache = {
    cache: new Map(),

    set(key, data, ttl = 300000) { // 5ë¶„ TTL
        this.cache.set(key, {
            data,
            expires: Date.now() + ttl
        });
    },

    get(key) {
        const cached = this.cache.get(key);
        if (cached && Date.now() < cached.expires) {
            return cached.data;
        }
        this.cache.delete(key);
        return null;
    }
};

// ì§€ì—° ë¡œë”©
const LazyTemplateRenderer = React.lazy(() =>
    import('./components/TemplateRenderer')
);

// ë©”ëª¨ì´ì œì´ì…˜
const MemoizedTemplateRenderer = React.memo(TemplateRenderer, (prevProps, nextProps) => {
    return prevProps.htmlContent === nextProps.htmlContent;
});
```

---

## âœ… 8. ìš”ì•½

ì´ ì†”ë£¨ì…˜ì˜ í•µì‹¬ íŠ¹ì§•:

### ğŸ¯ **ì™„ì „í•œ í†µí•©**

- FTLì—ì„œ JavaScript ì™„ì „ ì§€ì›
- React.js ì™¸ë¶€ ì„œë²„ì—ì„œ ì‹¤ì‹œê°„ ë°ì´í„° ë°”ì¸ë”©
- ì–‘ë°©í–¥ í†µì‹  ë° ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸

### ğŸ”„ **ë°ì´í„° í”Œë¡œìš°**

1. **FTL** â†’ HTML + Metadata + JavaScript ìƒì„±
2. **React** â†’ HTML ìˆ˜ì‹  ë° ë©”íƒ€ë°ì´í„° íŒŒì‹±
3. **API** â†’ ì‹¤ì œ ë°ì´í„° ì¡°íšŒ
4. **Binding** â†’ DOM ìš”ì†Œ ì—…ë°ì´íŠ¸
5. **Lifecycle** â†’ onReady, onDataBound, onDestroy ì´ë²¤íŠ¸

### ğŸš€ **í™•ì¥ ê°€ëŠ¥ì„±**

- ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (WebSocket)
- ìºì‹± ë° ì„±ëŠ¥ ìµœì í™”
- ì˜¤ë¥˜ ì²˜ë¦¬ ë° í´ë°±
- ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„

ì´ ë°©ì‹ìœ¼ë¡œ FTLê³¼ React.jsë¥¼ ì™„ë²½í•˜ê²Œ í†µí•©í•˜ì—¬ ë™ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•œ í…œí”Œë¦¿ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸ‰