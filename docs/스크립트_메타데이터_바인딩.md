# FTL + JavaScript + React.js 외부 서버 데이터 바인딩 완전 가이드

## 🎯 개요

FreeMarker 템플릿(.ftl)에서 **JavaScript를 포함하여 HTML을 생성**하고, **React.js 외부 서버에서 동적으로 데이터를 바인딩**하는 완전한 솔루션입니다.

### 🔄 시스템 아키텍처

```
[FTL 서버] → [HTML + JS + Metadata] → [React.js 서버] → [API 조회] → [데이터 바인딩] → [렌더링]
```

---

## 📝 1. FTL에서 JavaScript 사용

### 기본 JavaScript 포함 예시

```ftl
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>${document.title!"동적 대시보드"}</title>
    
    <!-- FTL에서 메타데이터를 JSON으로 임베딩 -->
    <script id="template-metadata" type="application/json">
    {
        "templateId": "${template.id!'dashboard'}",
        "version": "${template.version!'1.0.0'}",
        "dataBindings": {
            "user": {
                "endpoint": "/api/users/${user.id!'current'}",
                "fields": ["name", "email", "avatar", "role"],
                "fallback": {
                    "name": "${user.name!'사용자'}",
                    "email": "${user.email!''}",
                    "avatar": "${user.avatar!'/images/default-avatar.png'}",
                    "role": "${user.role!'user'}"
                }
            },
            "dashboard": {
                "endpoint": "/api/dashboard/stats",
                "fields": ["sales", "orders", "users"],
                "fallback": {
                    "sales": ${dashboard.sales!0},
                    "orders": ${dashboard.orders!0},
                    "users": ${dashboard.users!0}
                }
            }
        },
        "config": {
            "apiBaseUrl": "${api.baseUrl!'http://localhost:3001'}",
            "refreshInterval": ${config.refreshInterval!30000},
            "debug": ${config.debug!false}
        }
    }
    </script>
</head>
<body>
    <!-- 로딩 상태 -->
    <div id="loading-overlay">
        <div class="spinner">데이터를 불러오는 중...</div>
    </div>

    <!-- 메인 컨텐츠 -->
    <div id="main-content" style="display: none;">
        <header>
            <h1>대시보드</h1>
            <div class="user-info">
                <img data-bind="user.avatar" src="${user.avatar!'/images/default-avatar.png'}" alt="프로필" />
                <span data-bind="user.name">${user.name!'사용자'}</span>
                <span data-bind="user.email" class="email">${user.email!''}</span>
            </div>
        </header>

        <main class="dashboard">
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>총 매출</h3>
                    <span data-bind="dashboard.sales" data-format="currency">
                        ${dashboard.sales!0}
                    </span>
                </div>
                <div class="stat-card">
                    <h3>주문 수</h3>
                    <span data-bind="dashboard.orders" data-format="number">
                        ${dashboard.orders!0}
                    </span>
                </div>
                <div class="stat-card">
                    <h3>사용자 수</h3>
                    <span data-bind="dashboard.users" data-format="number">
                        ${dashboard.users!0}
                    </span>
                </div>
            </div>
        </main>
    </div>

    <!-- 데이터 바인딩 JavaScript -->
    <script>
    class TemplateDataBinder {
        constructor() {
            this.metadata = null;
            this.boundData = {};
            this.isReady = false;
            this.refreshTimer = null;
            this.init();
        }

        async init() {
            try {
                // 메타데이터 로딩
                const metadataScript = document.getElementById('template-metadata');
                this.metadata = JSON.parse(metadataScript.textContent);
                
                console.log('🚀 Template initialized:', this.metadata.templateId);
                
                // React 서버에서 데이터 바인딩
                await this.bindDataFromReactServer();
                
                // onReady 이벤트 호출
                this.onReady();
                
            } catch (error) {
                console.error('❌ Initialization failed:', error);
                this.onError(error);
            }
        }

        async bindDataFromReactServer() {
            const { dataBindings, config } = this.metadata;
            
            console.log('🔄 Starting data binding from React server...');
            
            for (const [key, binding] of Object.entries(dataBindings)) {
                try {
                    console.log(`📥 Fetching ${key} from ${binding.endpoint}`);
                    
                    const data = await this.fetchFromReactAPI(binding.endpoint, config);
                    
                    if (data) {
                        this.boundData[key] = data;
                        this.updateUIElements(key, data);
                        console.log(`✅ ${key} data bound successfully`);
                    } else {
                        console.log(`⚠️ Using fallback data for ${key}`);
                        this.boundData[key] = binding.fallback;
                        this.updateUIElements(key, binding.fallback);
                    }
                    
                } catch (error) {
                    console.error(`❌ Failed to bind ${key}:`, error);
                    this.boundData[key] = binding.fallback;
                    this.updateUIElements(key, binding.fallback);
                }
            }
            
            console.log('🎉 Data binding completed');
            this.onDataBound();
        }

        async fetchFromReactAPI(endpoint, config) {
            const url = `${config.apiBaseUrl}${endpoint}`;
            
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Template-ID': this.metadata.templateId,
                        'X-Requested-With': 'TemplateDataBinder'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return await response.json();
                
            } catch (error) {
                console.error(`Network error for ${endpoint}:`, error);
                return null;
            }
        }

        updateUIElements(dataKey, data) {
            const elements = document.querySelectorAll(`[data-bind^="${dataKey}."]`);
            
            elements.forEach(element => {
                const bindPath = element.getAttribute('data-bind');
                const fieldPath = bindPath.replace(`${dataKey}.`, '');
                const value = this.getNestedValue(data, fieldPath);
                
                if (value !== undefined) {
                    this.setElementValue(element, value);
                    element.classList.remove('data-placeholder');
                } else {
                    console.warn(`⚠️ No value found for ${bindPath}`);
                }
            });
        }

        getNestedValue(obj, path) {
            return path.split('.').reduce((current, key) => 
                current && current[key] !== undefined ? current[key] : undefined, obj);
        }

        setElementValue(element, value) {
            const format = element.getAttribute('data-format');
            let displayValue = value;

            if (format === 'currency') {
                displayValue = new Intl.NumberFormat('ko-KR', {
                    style: 'currency',
                    currency: 'KRW'
                }).format(value);
            } else if (format === 'number') {
                displayValue = new Intl.NumberFormat('ko-KR').format(value);
            }

            if (element.tagName === 'INPUT') {
                element.value = displayValue;
            } else if (element.tagName === 'IMG') {
                element.src = value;
            } else {
                element.textContent = displayValue;
            }
        }

        // 🎯 생명주기 이벤트들
        onReady() {
            console.log('🎯 onReady: Template is ready and data is bound');
            
            document.getElementById('loading-overlay').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';
            
            this.isReady = true;
            
            // 자동 새로고침 설정
            this.setupAutoRefresh();
            
            // 커스텀 이벤트 발생
            document.dispatchEvent(new CustomEvent('templateReady', {
                detail: { templateId: this.metadata.templateId, boundData: this.boundData }
            }));
        }

        onDataBound() {
            console.log('📊 onDataBound: All data binding completed');
            
            document.dispatchEvent(new CustomEvent('dataBound', {
                detail: { boundData: this.boundData, timestamp: new Date().toISOString() }
            }));
        }

        onDestroy() {
            console.log('💀 onDestroy: Cleaning up template');
            
            if (this.refreshTimer) {
                clearInterval(this.refreshTimer);
            }
            
            document.dispatchEvent(new CustomEvent('templateDestroy', {
                detail: { templateId: this.metadata.templateId }
            }));
        }

        onError(error) {
            console.error('💥 onError:', error);
            document.getElementById('loading-overlay').innerHTML = `
                <div style="text-align: center; color: red;">
                    <h3>오류가 발생했습니다</h3>
                    <p>${error.message}</p>
                    <button onclick="location.reload()">다시 시도</button>
                </div>
            `;
        }

        setupAutoRefresh() {
            const interval = this.metadata.config.refreshInterval;
            if (interval > 0) {
                this.refreshTimer = setInterval(() => {
                    console.log('🔄 Auto refreshing data...');
                    this.bindDataFromReactServer();
                }, interval);
            }
        }

        // 공개 API
        refresh() {
            return this.bindDataFromReactServer();
        }

        getData(key) {
            return this.boundData[key];
        }
    }

    // 전역 인스턴스
    let templateBinder;

    document.addEventListener('DOMContentLoaded', () => {
        templateBinder = new TemplateDataBinder();
    });

    window.addEventListener('beforeunload', () => {
        if (templateBinder) {
            templateBinder.onDestroy();
        }
    });

    // 전역 API
    window.TemplateAPI = {
        refresh: () => templateBinder?.refresh(),
        getData: (key) => templateBinder?.getData(key),
        isReady: () => templateBinder?.isReady || false
    };
    </script>

    <!-- FTL에서 추가 스크립트 (조건부) -->
    <#if customScripts?? && customScripts?has_content>
        <#list customScripts as script>
            <script src="${script}"></script>
        </#list>
    </#if>
</body>
</html>
```

---

## ⚛️ 2. React.js 외부 서버 구현

### 프로젝트 구조

```
react-template-server/
├── src/
│   ├── components/
│   │   ├── TemplateRenderer.jsx
│   │   └── TemplateProcessor.jsx
│   ├── services/
│   │   ├── apiService.js
│   │   └── templateService.js
│   ├── hooks/
│   │   └── useTemplateData.js
│   └── App.jsx
├── server/
│   ├── api/
│   │   ├── users.js
│   │   ├── dashboard.js
│   │   └── templates.js
│   └── server.js
└── package.json
```

### React 컴포넌트: TemplateRenderer.jsx

```jsx
import React, {useState, useEffect, useRef} from 'react';
import {apiService} from '../services/apiService';
import {templateService} from '../services/templateService';

const TemplateRenderer = ({htmlContent, onReady, onError}) => {
    const [isProcessing, setIsProcessing] = useState(true);
    const [processedHtml, setProcessedHtml] = useState('');
    const [templateData, setTemplateData] = useState({});
    const containerRef = useRef(null);

    useEffect(() => {
        if (htmlContent) {
            processTemplate(htmlContent);
        }
    }, [htmlContent]);

    const processTemplate = async (html) => {
        try {
            console.log('🚀 React: Starting template processing...');

            // 1. HTML에서 메타데이터 추출
            const metadata = templateService.extractMetadata(html);
            console.log('📋 Extracted metadata:', metadata);

            // 2. 각 데이터 바인딩에 대해 API 호출
            const boundData = {};

            for (const [key, binding] of Object.entries(metadata.dataBindings)) {
                try {
                    console.log(`📥 React: Fetching ${key} from ${binding.endpoint}`);

                    const data = await apiService.fetchData(binding.endpoint);
                    boundData[key] = data || binding.fallback;

                    console.log(`✅ React: ${key} data fetched:`, data);
                } catch (error) {
                    console.error(`❌ React: Failed to fetch ${key}:`, error);
                    boundData[key] = binding.fallback;
                }
            }

            // 3. HTML에 데이터 바인딩 적용
            const processedHtml = templateService.bindDataToHTML(html, boundData, metadata);

            setTemplateData(boundData);
            setProcessedHtml(processedHtml);
            setIsProcessing(false);

            console.log('🎉 React: Template processing completed');

            // 4. DOM에 삽입 후 JavaScript 실행
            setTimeout(() => {
                executeTemplateScripts(boundData, metadata);
            }, 100);

        } catch (error) {
            console.error('💥 React: Template processing failed:', error);
            setIsProcessing(false);
            onError?.(error);
        }
    };

    const executeTemplateScripts = (boundData, metadata) => {
        try {
            console.log('⚡ React: Executing template scripts...');

            // HTML에 포함된 JavaScript 실행을 위한 커스텀 이벤트 발생
            const event = new CustomEvent('reactTemplateReady', {
                detail: {
                    boundData,
                    metadata,
                    reactContext: {
                        updateData: (key, newData) => updateTemplateData(key, newData),
                        refreshData: () => processTemplate(htmlContent),
                        getReactState: () => templateData
                    }
                }
            });

            window.dispatchEvent(event);
            onReady?.(boundData, metadata);

        } catch (error) {
            console.error('❌ React: Script execution failed:', error);
            onError?.(error);
        }
    };

    const updateTemplateData = (key, newData) => {
        setTemplateData(prev => ({
            ...prev,
            [key]: newData
        }));

        // DOM 요소들도 업데이트
        templateService.updateDOMElements(key, newData);
    };

    if (isProcessing) {
        return (
            <div className="template-processing">
                <div className="spinner">
                    <div className="spinner-border" role="status">
                        <span className="sr-only">템플릿 처리 중...</span>
                    </div>
                </div>
                <p>React에서 템플릿을 처리하고 있습니다...</p>
            </div>
        );
    }

    return (
        <div
            ref={containerRef}
            className="template-container"
            dangerouslySetInnerHTML={{__html: processedHtml}}
        />
    );
};

export default TemplateRenderer;
```

### React Hook: useTemplateData.js

```jsx
import {useState, useEffect, useCallback} from 'react';
import {apiService} from '../services/apiService';

export const useTemplateData = (metadata) => {
    const [data, setData] = useState({});
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const fetchData = useCallback(async () => {
        if (!metadata?.dataBindings) return;

        setLoading(true);
        setError(null);

        try {
            const results = {};

            // 병렬로 모든 API 호출
            const promises = Object.entries(metadata.dataBindings).map(async ([key, binding]) => {
                try {
                    const result = await apiService.fetchData(binding.endpoint);
                    results[key] = result || binding.fallback;
                } catch (err) {
                    console.error(`Failed to fetch ${key}:`, err);
                    results[key] = binding.fallback;
                }
            });

            await Promise.all(promises);

            setData(results);
            console.log('🎯 useTemplateData: All data fetched:', results);

        } catch (err) {
            setError(err);
            console.error('💥 useTemplateData: Fetch failed:', err);
        } finally {
            setLoading(false);
        }
    }, [metadata]);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    const updateData = useCallback((key, newData) => {
        setData(prev => ({
            ...prev,
            [key]: newData
        }));
    }, []);

    const refreshData = useCallback(() => {
        return fetchData();
    }, [fetchData]);

    return {
        data,
        loading,
        error,
        updateData,
        refreshData,
        refetch: fetchData
    };
};
```

### 템플릿 서비스: templateService.js

```javascript
class TemplateService {
    extractMetadata(html) {
        try {
            const metadataMatch = html.match(/<script id="template-metadata"[^>]*>([\s\S]*?)<\/script>/);
            if (!metadataMatch) {
                throw new Error('Template metadata not found');
            }

            return JSON.parse(metadataMatch[1]);
        } catch (error) {
            console.error('Failed to extract metadata:', error);
            throw error;
        }
    }

    bindDataToHTML(html, boundData, metadata) {
        let processedHtml = html;

        // 메타데이터를 실제 데이터로 업데이트
        const updatedMetadata = {
            ...metadata,
            boundData,
            processedAt: new Date().toISOString()
        };

        // 메타데이터 스크립트 태그 업데이트
        processedHtml = processedHtml.replace(
            /<script id="template-metadata"[^>]*>[\s\S]*?<\/script>/,
            `<script id="template-metadata" type="application/json">
            ${JSON.stringify(updatedMetadata, null, 2)}
            </script>`
        );

        // data-bind 속성을 가진 요소들의 기본값 업데이트
        Object.entries(boundData).forEach(([key, data]) => {
            Object.entries(data).forEach(([field, value]) => {
                const bindAttr = `${key}.${field}`;
                const regex = new RegExp(`data-bind="${bindAttr}"[^>]*>([^<]*)<`, 'g');

                processedHtml = processedHtml.replace(regex, (match, currentContent) => {
                    const formattedValue = this.formatValue(value, match);
                    return match.replace(currentContent, formattedValue);
                });
            });
        });

        return processedHtml;
    }

    formatValue(value, elementMatch) {
        if (elementMatch.includes('data-format="currency"')) {
            return new Intl.NumberFormat('ko-KR', {
                style: 'currency',
                currency: 'KRW'
            }).format(value);
        } else if (elementMatch.includes('data-format="number"')) {
            return new Intl.NumberFormat('ko-KR').format(value);
        }

        return value;
    }

    updateDOMElements(key, data) {
        const elements = document.querySelectorAll(`[data-bind^="${key}."]`);

        elements.forEach(element => {
            const bindPath = element.getAttribute('data-bind');
            const fieldPath = bindPath.replace(`${key}.`, '');
            const value = this.getNestedValue(data, fieldPath);

            if (value !== undefined) {
                if (element.tagName === 'IMG') {
                    element.src = value;
                } else if (element.tagName === 'INPUT') {
                    element.value = value;
                } else {
                    const formattedValue = this.formatValue(value, element.outerHTML);
                    element.textContent = formattedValue;
                }
            }
        });
    }

    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) =>
            current && current[key] !== undefined ? current[key] : undefined, obj);
    }
}

export const templateService = new TemplateService();
```

### API 서비스: apiService.js

```javascript
class ApiService {
    constructor() {
        this.baseURL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001';
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5분
    }

    async fetchData(endpoint) {
        const cacheKey = endpoint;
        const cached = this.cache.get(cacheKey);

        // 캐시 확인
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            console.log(`📦 Using cached data for ${endpoint}`);
            return cached.data;
        }

        try {
            const url = `${this.baseURL}${endpoint}`;
            console.log(`🌐 Fetching from: ${url}`);

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'React-Template-Server'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            // 캐시에 저장
            this.cache.set(cacheKey, {
                data,
                timestamp: Date.now()
            });

            return data;

        } catch (error) {
            console.error(`API call failed for ${endpoint}:`, error);
            throw error;
        }
    }

    clearCache(endpoint) {
        if (endpoint) {
            this.cache.delete(endpoint);
        } else {
            this.cache.clear();
        }
    }
}

export const apiService = new ApiService();
```

---

## 🌐 3. Express.js API 서버 (React 백엔드)

### server.js

```javascript
const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3001;

// 미들웨어
app.use(cors());
app.use(express.json({limit: '10mb'}));
app.use(express.static('public'));

// 로깅 미들웨어
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
    next();
});

// 사용자 API
app.get('/api/users/:id', async (req, res) => {
    try {
        const userId = req.params.id;

        // 실제로는 데이터베이스에서 조회
        const userData = {
            current: {
                name: '김개발자',
                email: 'developer@example.com',
                avatar: '/images/avatar-developer.jpg',
                role: 'admin'
            },
            'user-123': {
                name: '박사용자',
                email: 'user@example.com',
                avatar: '/images/avatar-user.jpg',
                role: 'user'
            }
        };

        const user = userData[userId] || userData.current;

        console.log(`👤 User data requested for: ${userId}`);
        res.json(user);

    } catch (error) {
        console.error('User API error:', error);
        res.status(500).json({error: 'Failed to fetch user data'});
    }
});

// 대시보드 통계 API
app.get('/api/dashboard/stats', async (req, res) => {
    try {
        // 실제로는 데이터베이스에서 계산
        const stats = {
            sales: Math.floor(Math.random() * 10000000) + 5000000,
            orders: Math.floor(Math.random() * 1000) + 500,
            users: Math.floor(Math.random() * 10000) + 5000
        };

        console.log('📊 Dashboard stats requested');
        res.json(stats);

    } catch (error) {
        console.error('Dashboard API error:', error);
        res.status(500).json({error: 'Failed to fetch dashboard stats'});
    }
});

// 알림 API
app.get('/api/notifications/count', async (req, res) => {
    try {
        const notifications = {
            unread: Math.floor(Math.random() * 20),
            total: Math.floor(Math.random() * 100) + 50
        };

        console.log('🔔 Notifications requested');
        res.json(notifications);

    } catch (error) {
        console.error('Notifications API error:', error);
        res.status(500).json({error: 'Failed to fetch notifications'});
    }
});

// 템플릿 처리 API (React 서버로부터 HTML 수신)
app.post('/api/templates/process', async (req, res) => {
    try {
        const {html, templateId} = req.body;

        console.log(`📝 Processing template: ${templateId}`);

        // 여기서 추가적인 서버사이드 처리 가능
        // 예: 권한 확인, 로깅, 분석 등

        res.json({
            success: true,
            templateId,
            processedAt: new Date().toISOString(),
            message: 'Template processed successfully'
        });

    } catch (error) {
        console.error('Template processing error:', error);
        res.status(500).json({error: 'Failed to process template'});
    }
});

// 헬스체크
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
    });
});

app.listen(PORT, () => {
    console.log(`🚀 React Template Server running on port ${PORT}`);
    console.log(`📊 Dashboard API: http://localhost:${PORT}/api/dashboard/stats`);
    console.log(`👤 User API: http://localhost:${PORT}/api/users/current`);
    console.log(`💊 Health Check: http://localhost:${PORT}/health`);
});
```

---

## 🎭 4. 생명주기 이벤트 상세

### onReady 이벤트 처리

```javascript
// FTL에서 생성된 HTML의 JavaScript
window.addEventListener('reactTemplateReady', (event) => {
    const {boundData, metadata, reactContext} = event.detail;

    console.log('🎯 React와 Template 연동 완료!');

    // React 컨텍스트를 통한 양방향 통신
    window.ReactAPI = {
        updateData: reactContext.updateData,
        refreshData: reactContext.refreshData,
        getReactState: reactContext.getReactState
    };

    // 템플릿 자체 onReady 실행
    if (window.templateBinder) {
        window.templateBinder.onReady();
    }

    // 추가 초기화 로직
    initializeCharts(boundData);
    setupRealTimeUpdates();
});

function initializeCharts(data) {
    // 차트 라이브러리 초기화
    if (window.Chart && data.dashboard) {
        const ctx = document.getElementById('salesChart');
        if (ctx) {
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['1월', '2월', '3월', '4월', '5월', '6월'],
                    datasets: [{
                        label: '매출',
                        data: generateChartData(data.dashboard.sales),
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1
                    }]
                }
            });
        }
    }
}

function setupRealTimeUpdates() {
    // WebSocket 연결 (선택적)
    if (window.io) {
        const socket = io();

        socket.on('dashboard-update', (data) => {
            console.log('📊 Real-time dashboard update received');
            window.ReactAPI.updateData('dashboard', data);
        });

        socket.on('user-update', (data) => {
            console.log('👤 Real-time user update received');
            window.ReactAPI.updateData('user', data);
        });
    }
}
```

### onDestroy 이벤트 처리

```javascript
window.addEventListener('beforeunload', () => {
    console.log('💀 Page unloading - cleaning up...');

    // WebSocket 연결 정리
    if (window.socket) {
        window.socket.disconnect();
    }

    // 타이머 정리
    if (window.refreshTimer) {
        clearInterval(window.refreshTimer);
    }

    // React에게 정리 알림
    if (window.ReactAPI) {
        const event = new CustomEvent('templateDestroy', {
            detail: {timestamp: new Date().toISOString()}
        });
        window.dispatchEvent(event);
    }
});
```

---

## 🔄 5. 완전한 통합 예시

### App.jsx (React 메인 컴포넌트)

```jsx
import React, {useState, useEffect} from 'react';
import TemplateRenderer from './components/TemplateRenderer';
import './App.css';

function App() {
    const [htmlContent, setHtmlContent] = useState('');
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        // FTL 서버에서 HTML 수신 시뮬레이션
        // 실제로는 POST 요청으로 받아올 것
        fetchTemplateFromFTLServer();
    }, []);

    const fetchTemplateFromFTLServer = async () => {
        try {
            // 실제 FTL 서버에서 HTML을 받아오는 로직
            // 여기서는 시뮬레이션
            const mockHtmlFromFTL = await simulateFTLResponse();

            setHtmlContent(mockHtmlFromFTL);
            setIsLoading(false);

        } catch (err) {
            setError(err);
            setIsLoading(false);
        }
    };

    const simulateFTLResponse = () => {
        // 실제로는 FTL 서버에서 생성된 HTML이 여기에 들어감
        return Promise.resolve(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>동적 대시보드</title>
                <script id="template-metadata" type="application/json">
                {
                    "templateId": "dashboard-001",
                    "dataBindings": {
                        "user": {
                            "endpoint": "/api/users/current",
                            "fallback": {"name": "사용자", "email": ""}
                        },
                        "dashboard": {
                            "endpoint": "/api/dashboard/stats", 
                            "fallback": {"sales": 0, "orders": 0}
                        }
                    }
                }
                </script>
            </head>
            <body>
                <h1>대시보드</h1>
                <p>안녕하세요, <span data-bind="user.name">사용자</span>님!</p>
                <p>총 매출: <span data-bind="dashboard.sales" data-format="currency">0</span></p>
            </body>
            </html>
        `);
    };

    const handleTemplateReady = (boundData, metadata) => {
        console.log('🎉 Template ready in React:', {boundData, metadata});

        // 분석 이벤트 전송
        if (window.gtag) {
            window.gtag('event', 'template_rendered', {
                template_id: metadata.templateId,
                data_sources: Object.keys(boundData).length
            });
        }
    };

    const handleTemplateError = (error) => {
        console.error('💥 Template error in React:', error);
        setError(error);
    };

    if (isLoading) {
        return (
            <div className="app-loading">
                <div className="spinner-border" role="status">
                    <span className="sr-only">FTL 템플릿 로딩 중...</span>
                </div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="app-error">
                <h2>오류가 발생했습니다</h2>
                <p>{error.message}</p>
                <button onClick={() => window.location.reload()}>
                    다시 시도
                </button>
            </div>
        );
    }

    return (
        <div className="App">
            <header className="app-header">
                <h1>React Template Renderer</h1>
                <p>FTL → HTML → React → Data Binding → Final Render</p>
            </header>

            <main className="app-main">
                <TemplateRenderer
                    htmlContent={htmlContent}
                    onReady={handleTemplateReady}
                    onError={handleTemplateError}
                />
            </main>

            <footer className="app-footer">
                <p>Powered by FreeMarker + React.js</p>
            </footer>
        </div>
    );
}

export default App;
```

---

## 🚀 6. 실행 및 테스트

### 설치 및 실행

```bash
# React 프로젝트 생성
npx create-react-app react-template-server
cd react-template-server

# 필요한 패키지 설치
npm install express cors
npm install -D nodemon

# 개발 서버 실행
npm run dev     # React 개발 서버 (3000)
npm run server  # Express API 서버 (3001)
```

### package.json 스크립트

```json
{
  "scripts": {
    "start": "react-scripts start",
    "server": "nodemon server/server.js",
    "dev": "concurrently \"npm run server\" \"npm start\"",
    "build": "react-scripts build",
    "test": "react-scripts test"
  }
}
```

---

## 📊 7. 성능 및 모니터링

### 성능 최적화

```javascript
// 데이터 캐싱
const DataCache = {
    cache: new Map(),

    set(key, data, ttl = 300000) { // 5분 TTL
        this.cache.set(key, {
            data,
            expires: Date.now() + ttl
        });
    },

    get(key) {
        const cached = this.cache.get(key);
        if (cached && Date.now() < cached.expires) {
            return cached.data;
        }
        this.cache.delete(key);
        return null;
    }
};

// 지연 로딩
const LazyTemplateRenderer = React.lazy(() =>
    import('./components/TemplateRenderer')
);

// 메모이제이션
const MemoizedTemplateRenderer = React.memo(TemplateRenderer, (prevProps, nextProps) => {
    return prevProps.htmlContent === nextProps.htmlContent;
});
```

---

## ✅ 8. 요약

이 솔루션의 핵심 특징:

### 🎯 **완전한 통합**

- FTL에서 JavaScript 완전 지원
- React.js 외부 서버에서 실시간 데이터 바인딩
- 양방향 통신 및 실시간 업데이트

### 🔄 **데이터 플로우**

1. **FTL** → HTML + Metadata + JavaScript 생성
2. **React** → HTML 수신 및 메타데이터 파싱
3. **API** → 실제 데이터 조회
4. **Binding** → DOM 요소 업데이트
5. **Lifecycle** → onReady, onDataBound, onDestroy 이벤트

### 🚀 **확장 가능성**

- 실시간 업데이트 (WebSocket)
- 캐싱 및 성능 최적화
- 오류 처리 및 폴백
- 모니터링 및 분석

이 방식으로 FTL과 React.js를 완벽하게 통합하여 동적이고 확장 가능한 템플릿 시스템을 구축할 수 있습니다! 🎉